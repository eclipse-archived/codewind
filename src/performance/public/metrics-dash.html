<!--
******************************************************************************
 * Copyright 2017 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************
-->
<!DOCTYPE html>
<meta charset="utf-8">

<link rel="stylesheet" href="graphmetrics/bootstrap-3.3.7-dist/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="graphmetrics/css/themes.css" title="Themes">

<head>
  <title>Codewind Application Metrics Dashboard</title>
</head>

<body>
  <div>
  <!--<h1>Application Metrics Dashboard for Node.js</h1>-->
  <!-- load the d3.js library -->
  <script src="socket.io/socket.io.js"></script>
  <script src="graphmetrics/d3/d3.v3.min.js"></script>
  <script src="graphmetrics/jquery/jquery-3.1.1.min.js"></script>
  <script src="graphmetrics/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
  <script>
    function toggleMenu() {
      $('#sideMenu').toggleClass( "expanded" );
    }

    // function toggleProfiling() {
    //   if (profiling_enabled) {
    //     socket.emit('disableprofiling');
    //   } else {
    //     socket.emit('enableprofiling');
    //   }
    // }

    const queryStringValues = new URLSearchParams(window.location.search)
    if (queryStringValues.get('theme')==='dark') {
        $('body').addClass( "darkmode" )
    } else {
        $('body').addClass( "lightmode" )
    }
  </script>

  <div class="headerDiv">
    <span class="sidenavButton" onclick="toggleMenu()">&#9776;</span>
    <span class="active" onclick="getMetricsAndUpdateGraphs()">&#9776;</span>
    <span class="active" onclick="getProfilingDataAndUpdateFlameGraph()">&#9776;</span>
    <span class="active" onclick="getEnvDataAndUpdateEnvSummary()">&#9776;</span>
    <span class="leftHeader">Application Metrics for Node.js</span>
    <span class="rightHeader">
      <a class="docLink" href="https://developer.ibm.com/node/application-metrics-node-js/" target="_blank">Go To Documentation</a>
    </span>
  </div>

  <div id="sideMenu" class="sidenav">
    <!-- <a class="sidenavEntry" onclick="socket.emit('heapdump'); toggleMenu()">Trigger Heap Dump</a>
    <a class="sidenavEntry" onclick="socket.emit('nodereport'); toggleMenu()">Trigger Node Report</a> -->
    <!-- <a class="sidenavEntry" id="toggle-profiling" onclick="toggleProfiling(); toggleMenu()"></a> -->
    <a class="sidenavEntry" id="clear-profiling" onclick="clearProfilingData(); toggleMenu()">Clear Profiling Data</a>
  </div>

  <div id="tabs" class="container">

    <ul class="nav nav-tabs">
      <li class="active">
        <a href="#dashboard" id="main-tab" data-toggle="tab">Dashboard</a>
      </li>
      <li>
        <a href="#profiling" id="profiing-tab" data-toggle="tab">Profiling</a>
      </li>
      <li>
        <a href="#summary" id="summary-tab" data-toggle="tab">Summary</a>
      </li>
    </ul>

    <div class="tab-content ">
      <div class="tab-pane active" id="dashboard">
        <div class="container-fluid">
          <div class="row">
            <div class="col-md-5 hideable" id="cpuDiv1"></div>
            <div class="col-md-7 hideable" id="httpDiv1"></div>
          </div>
          <div class="row">
            <div class="col-md-5 hideable" id="memDiv1"></div>
            <div class="col-md-7 hideable" id="httpDiv2"></div>
          </div>

          <div class="row">
            <div class="col-md-5 hideable" id="gcDiv"></div>
            <div class="col-md-7 hideable" id="httpOBDiv"></div>
          </div>

          <div class="row">
            <div class="col-md-5 hideable" id="loopDiv"></div>
            <div class="col-md-7 hideable" id="probeEventsDiv"></div>
          </div>
          <div class="row">
            <div class="col-md-7 hideable" id="httpDiv3"></div>
          </div>
        </div>
      </div>

      <div class="tab-pane" id="profiling">
        <div id="flameDiv"></div>
      </div>
      <div class="tab-pane" id="summary">
        <div class="container-fluid">
          <div class="row">
            <div class="graph-container col-md-7">
              <div class="col-md-12 height-fill hideable" id="httpSummaryDiv"></div>
            </div>
            <div class="graph-container col-md-5">
              <div class="col-md-12 hideable" id="envDiv"></div>
              <div class="col-md-12 hideable" id="summaryDiv"></div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div class="modal fade" id="heapdumpModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title" font-color=black>Heap Snapshot</h4>
        </div>
        <div class="modal-body"></div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script type="text/javascript" src="graphmetrics/js/i18n.js"></script>
  <script>
    // Global variables
    var localizedStrings = {};
    var monitoringStartTime = new Date();
    var maxTimeWindow = 900000; // 15 minutes

    // Initialise graph and canvas dimensions
    var margin = {
        top: 50,
        right: 20,
        bottom: 50,
        shortBottom: 30,
        left: 60
      },
      canvasWidth = $("#cpuDiv1").width() - 8, // -8 for margins and borders
      httpCanvasWidth = $("#httpDiv1").width() - 8,
      graphWidth = canvasWidth - margin.left - margin.right,
      httpGraphWidth = httpCanvasWidth - margin.left - margin.right,
      canvasHeight = 250,
      tallerGraphHeight = canvasHeight - margin.top - margin.shortBottom,
      graphHeight = canvasHeight - margin.top - margin.bottom;

    // // User may have requested appmetrics-dash/index.html
    let dashboardRoot = location.pathname.split('index.html')[0] || '/';

    function getTimeFormat() {
      var currentTime = new Date()
      if (currentTime.getMinutes() - monitoringStartTime.getMinutes() >= 3 ||
        currentTime.getHours() > monitoringStartTime.getHours()) {
        return d3.time.format("%H:%M");
      } else {
        return d3.time.format("%H:%M:%S");
      }
    }

    populateLocalizedStrings();
  </script>

  <!-- <script type="text/javascript" src="graphmetrics/js/header.js"></script> -->
  <script type="text/javascript" src="graphmetrics/js/textTable.js"></script>
  <script type="text/javascript" src="graphmetrics/js/nodeReport.js"></script>
  <script type="text/javascript" src="graphmetrics/js/cpuChart.js"></script>

  <script type="text/javascript" src="graphmetrics/js/httpHttpsRequestsChart.js"></script>
  <script type="text/javascript" src="graphmetrics/js/httpThroughPutChart.js"></script>
  <script type="text/javascript" src="graphmetrics/js/top5.js"></script>
  <script type="text/javascript" src="graphmetrics/js/httpSummary.js"></script>
  <script type="text/javascript" src="graphmetrics/js/httpHttpsOutboundRequestsChart.js"></script>

  <script type="text/javascript" src="graphmetrics/js/memChart.js"></script>
  <script type="text/javascript" src="graphmetrics/js/gcChart.js"></script>
  <script type="text/javascript" src="graphmetrics/js/loopChart.js"></script>
  <script type="text/javascript" src="graphmetrics/js/probeEventsChart.js"></script>
  <script type="text/javascript" src="graphmetrics/js/flamegraph.js"></script>
  <script type="text/javascript" src="profiling.js"></script>
  <script type="module" src="parse-prometheus-text-format/dist/parse-prometheus-text-format.umd.js"></script>

  <script>
    const appPort = 32770; // TODO get this from PORT env variable?
    const pollInterval = 2000;

    // TODO remove when finished dev
    let maxPolls = 8;
    let numPollsToMetricsCodewind = 0;
    let numPollsToMetricsCodewindProfiling = 0;

    // Summary data
    // CPU
    let totalProcessCPULoad = 0.0;
    let totalSystemCPULoad = 0.0;
    let numCPULoadSamples = 0;
    // GC
    let gcDurationTotal = 0.0;
    let maxHeapUsed = 0;

    const logAjaxResponseError = (jqXKR, textStatus, errorThrown) => {
      console.log('jqXKR');
      console.log(jqXKR);
      console.log(`textStatus: ${textStatus}`);
      console.log(`errorThrown: ${errorThrown}`);
    };

    getMetricsAndUpdateGraphs();
    // getProfilingDataAndUpdateFlameGraph();
    getEnvDataAndUpdateEnvSummary();


    function getMetricsAndUpdateGraphs() {
      const path = 'metrics/codewind';
      $.ajax({
        method: 'GET',
        url: `http://127.0.0.1:${appPort}/${path}`,
        crossDomain: true,
        error: logAjaxResponseError,
        success: (resBody) => {
          console.log("resBody");
          console.log(resBody);
          const time = Date.now();
          const metrics = parsePrometheusTextFormat(resBody);
          console.log('metrics');
          console.log(metrics);
          updateGraphs(time, metrics);
        },
        complete: () => {
          numPollsToMetricsCodewind++;
          if (numPollsToMetricsCodewind < maxPolls) {
            return setTimeout(
              () => getMetricsAndUpdateGraphs(path),
              pollInterval,
            );
          }
          console.log('finished polling');
        },
        timeout: 30000,
      });
    }

    function getProfilingDataAndUpdateFlameGraph() {
      const path = 'metrics/codewind/profiling';
      $.ajax({
        method: 'GET',
        url: `http://127.0.0.1:${appPort}/${path}`,
        crossDomain: true,
        error: logAjaxResponseError,
        success: (resBody) => {
          console.log("resBody");
          console.log(resBody);
          updateFlameGraph(resBody);
        },
        complete: () => {
          numPollsToMetricsCodewindProfiling++;
          if (numPollsToMetricsCodewindProfiling < maxPolls) {
            return setTimeout(
              () => getProfilingDataAndUpdateFlameGraph(),
              pollInterval,
            );
          }
          console.log('finished polling');
        },
        timeout: 30000,
      });
    }

    function getEnvDataAndUpdateEnvSummary() {
      const path = 'metrics/codewind/environment';
      $.ajax({
        method: 'GET',
        url: `http://127.0.0.1:${appPort}/${path}`,
        crossDomain: true,
        error: logAjaxResponseError,
        success: (resBody) => {
          console.log("resBody");
          console.log(resBody);
          envTable.populateTableJSON(JSON.stringify(resBody));
        },
        timeout: 30000,
      });
    }

    let indexOfLastViewedSample = 0;

    function updateFlameGraph(profilingSamples) {
      const newProfilingSamples = profilingSamples.slice(indexOfLastViewedSample);
      console.log('newProfilingSample');
      console.log(newProfilingSample);

      newProfilingSamples.forEach(sample => {
        processProfilingSample(sample);
      });
      indexOfLastViewedSample += newProfilingSamples.length;
    }

    function updateGraphs(time, metrics) {
      // const metricsAvailableInLanguage = {
      //   node: [
      //     'os_cpu_used_ratio', // = base:cpu_system_load_average
      //     'process_cpu_used_ratio', // = cpu_process_cpu_load_percent
      //     'os_resident_memory_bytes',
      //     'process_resident_memory_bytes',
      //     'process_virtual_memory_bytes',
      //     'http_request_duration_microseconds',
              // + my new stuff
      //   ],
      //   java: [
      //     'base:classloader_total_loaded_class_count',
      //     'base:gc_global_count',
      //     'base:cpu_system_load_average',
      //     'base:thread_count',
      //     'base:classloader_current_loaded_class_count',
      //     'base:gc_scavenge_time_seconds',
      //     'base:jvm_uptime_seconds',
      //     'base:memory_committed_heap_bytes',
      //     'base:thread_max_count',
      //     'base:cpu_available_processors',
      //     'base:thread_daemon_count',
      //     'base:gc_scavenge_count',
      //     'base:classloader_total_unloaded_class_count',
      //     'base:memory_max_heap_bytes',
      //     'base:cpu_process_cpu_load_percent',
      //     'base:memory_used_heap_bytes',
      //     'base:gc_global_time_seconds',
      //   ],
      // };
      const cpuData = { time, };
      const memData = { time, };
      const httpData = {
        time,
        "url":"/health" // TODO do I need this? or just add all http data together. if do need it: how to get this without using handler? handle multiple? research how other people do it
      };
      const eventLoopData = {}; // TODO this is based on the stuff from codewind-node-metrics.js
      const gcData = { time, }
      for (const metric of metrics) {
        const metricsObj = metric.metrics[0];
        const metricValue = metricsObj.value;
        if (['os_cpu_used_ratio', 'base:cpu_system_load_average'].includes(metric.name)) {
          cpuData.system = metricValue;
        } else if (['process_cpu_used_ratio', 'cpu_process_cpu_load_percent'].includes(metric.name)) {
          cpuData.process = metricValue;
        } else if (metric.name === 'os_resident_memory_bytes') {
          memData.physical_used = metricValue;
        } else if (metric.name === 'process_resident_memory_bytes') {
          memData.physical = metricValue;
        } else if (metric.name === 'process_virtual_memory_bytes') {
          memData.virtual = metricValue;

        } else if (metric.name === 'http_request_duration_microseconds') {
          httpData.total = metricsObj.count;
          httpData.average = metricsObj.sum / metricsObj.count;
          httpData.longest = metricsObj.quantiles['0.99']; // TODO: check this

        } else if (metric.name === 'event_loop_tick_min_milliseconds') {
          eventLoopData.minimum = metricValue;
        } else if (metric.name === 'event_loop_tick_max_milliseconds') {
          eventLoopData.maximum = metricValue;
        } else if (metric.name === 'event_loop_tick_count') {
          eventLoopData.count = metricValue;
        } else if (metric.name === 'event_loop_tick_average_milliseconds') {
          eventLoopData.average = metricValue;
        } else if (metric.name === 'event_loop_cpu_user') {
          eventLoopData.cpu_user = metricValue;
        } else if (metric.name === 'event_loop_cpu_system') {
          eventLoopData.cpu_system = metricValue;

        } else if (metric.name === 'heap_size_bytes') {
          gcData.size = metricValue;
        } else if (metric.name === 'heap_memory_used_bytes') {
          gcData.used = metricValue;
        } else if (metric.name === 'gc_cycle_duration_milliseconds') {
          gcData.duration = metricValue;
        }
      }

      processCPUData(
        cpuData,
        totalProcessCPULoad,
        totalSystemCPULoad,
        numCPULoadSamples,
      );
      updateMemData(JSON.stringify(memData));
      updateHttpData(JSON.stringify(httpData));
      updateLoopData(JSON.stringify(eventLoopData));
      processGCData(
        gcData,
        gcDurationTotal,
        maxHeapUsed,
      );
    }

    const summary = {
      cpu: {},
      gc: {},
      memoryPools: {},
    };

    let hostname = location.host.split(':')[0];
    let envTable = new TextTable('#envDiv', '#summary', localizedStrings.envTitle);
    let summaryTable = new TextTable('#summaryDiv', '#summary', localizedStrings.summaryTitle);
    let httpSummary = new HttpSummary('#httpSummaryDiv', '#summary', localizedStrings.httpSummaryTitle);
    httpSummary.setHttpSummaryOptions({host: hostname, filteredPath: dashboardRoot});

    function processCPUData(data, totalProcessCPULoad, totalSystemCPULoad, numCPULoadSamples) {
      updateCPUData(JSON.stringify(data));

      totalProcessCPULoad += data.process;
      totalSystemCPULoad += data.system;
      numCPULoadSamples++;
      const processMean = (totalProcessCPULoad / numCPULoadSamples);
      const systemMean = (totalSystemCPULoad / numCPULoadSamples);

      summary.cpu.processMean = processMean;
      summary.cpu.systemMean = systemMean;
      updateSummaryTable();
    }

    function processGCData(data) {
      updateGCData(JSON.stringify(data));

      const usedHeapAfterGCMax = Math.max(maxHeapUsed, data.used);
      summary.gc.usedHeapAfterGCMax = usedHeapAfterGCMax;

      // TODO which `process` do we need? from the app itself, or the monitoring?
      // gcDurationTotal += data.duration;
      // const timeSummary = (gcDurationTotal / (process.uptime() * 1000));
      // summary.gc.time = timeSummary;
      updateSummaryTable();
    }
    // socket.on('cpu', (data) => processCPUData(data));

    // TODO:
    // socket.on('environment', function(data) {
    //   envTable.populateTableJSON(data);
    // });

    // socket.on('loop', function(data) {
    //   updateLoopData(data);
    // });
    // socket.on('gc', function(data) {
    //   updateGCData(data);
    //   let json = JSON.parse(data);
    //   summary.gc.time = json.timeSummary;
    //   summary.gc.usedHeapAfterGCMax = json.usedHeapAfterGCMax;
    //   updateSummaryTable();
    // });
    // socket.on('http-outbound', function(data) {
    //   updateHttpOBData(data);
    // });
    // socket.on('http', function(data) {
    //   updateHttpData(data);
    // });
    // socket.on('https-outbound', function(data) {
    //   updateHttpsOBData(data);
    // });
    // socket.on('https', function(data) {
    //   updateHttpsData(data);
    // });
    // socket.on('http-urls', function(data) {
    //   httpSummary.updateURLData(data);
    // });
    // socket.on('probe-events', function(data) {
    //   updateProbesData(data);
    // });
    // socket.on('title', function(data) {
    //   updateHeader(data);
    // });

    function updateSummaryTable() {
      let summaryData = [];
      if (summary.cpu.processMean) {
         let value = new Number(summary.cpu.processMean);
         let valueStr = value.toLocaleString([],{style: 'percent', minimumSignificantDigits: 4, maximumSignificantDigits: 4});
         summaryData.push({Parameter: 'Average Process CPU', Value: valueStr});
      }
      if (summary.cpu.systemMean) {
          let value = new Number(summary.cpu.systemMean);
          let valueStr = value.toLocaleString([],{style: 'percent', minimumSignificantDigits: 4, maximumSignificantDigits: 4});
          summaryData.push({Parameter: 'Average System CPU', Value: valueStr});
       }
      if (summary.gc.time) {
          let value = new Number(summary.gc.time);
          let valueStr = value.toLocaleString([],{style: 'percent', minimumSignificantDigits: 4, maximumSignificantDigits: 4});
          summaryData.push({Parameter: 'Time Spent in GC', Value: `${valueStr}`});
      }
      if (summary.gc.usedHeapAfterGCMax) {
          summaryData.push({Parameter: 'Max Heap Used After GC', Value: `${summary.gc.usedHeapAfterGCMax} bytes`});
      }
      summaryTable.populateTable(summaryData);
    }

    let selected_tab = "main-tab"

    window.addEventListener('resize', resize);

    // Also re-size when we change tabs in case we re-sized
    // while the new tab wasn't visible.
    $('.nav-tabs a').on('shown.bs.tab', function(event) {
      selected_tab = event.target.id;
      resize();
    });

    function resize() {
      if (selected_tab == "main-tab") {
        canvasWidth = $("#cpuDiv1").width() - 8,
        httpCanvasWidth = $("#httpDiv1").width() - 8,
        graphWidth = canvasWidth - margin.left - margin.right,
        httpGraphWidth = httpCanvasWidth - margin.left - margin.right;
        resizeCPUChart();
        resizeHttpChart();
        resizeHttpOBChart();
        resizeGCChart();
        resizeLoopChart();
        resizeHttpThroughputChart();
        resizeMemChart();
        resizeProbesChart();
      } else if(selected_tab == "summary-tab") {
        envTable.resizeTable();
        summaryTable.resizeTable();
        httpSummary.resizeTable();
      } else {
        refreshFlameGraph();
      }
    }
  </script>
</div>
</body>

</html>
